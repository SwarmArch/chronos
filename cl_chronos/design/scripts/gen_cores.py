import sys, os
if len(sys.argv) < 2:
    print("Usage gen_config.py app <pipe>")
    exit(0)
app = sys.argv[1]
pipe = 0
if len(sys.argv) > 2:
    if (sys.argv[2].find("pipe") >= 0):
        pipe = 1;

# Should be run from cl_chronos/design
if pipe:
    configs = open("apps/"+app+"/config_pipe.vh")
else:
    configs = open("apps/"+app+"/config.vh")
arg_width = 0
app_id = 0
data_width = 32

is_hls = app.find("hls")>=0

cores = []

n_types = 0
n_app_threads = 0;

for line in configs:
    if (line.find('#') >=0):
        continue
    if ( line.find('USE_PIPELINED_TEMPLATE') >= 0):
       cmd = "cp apps/"+app+"/config_pipe.vh app_config.vh";
       print(cmd)
       os.system(cmd)
       # place an empty file in gen_core_spec.vh, since core.sv fails
       # compilation without it
       core_spec = open('gen_core_spec.vh','w')
       core_spec.write("")
       exit(0)
    if (line.find("ARG_WIDTH") >=0):
        arg_width = int(line.split()[1])
    if (line.find("APP_ID") >=0):
        app_id = int(line.split()[1])
    if (line.find("WARNING") >=0):
        print(line)
    if (line.find("DATA_WIDTH") >=0):
        # AXI WDATA and RDATA only. undo-log-width is still configurable
        data_width = int(line.split()[1])
    if (line.find("mt_core")>=0):
        [core_type, n_threads] = line.split()[1:3]
        if (n_threads <= 1) :
            printf("mt_core should have >1 thread")
            exit(0);
        cores.append( [core_type, n_types, n_threads, True])
        n_types += 1
        n_app_threads += int(n_threads);
    elif (line.find("core")>=0):
        [core_type, n_cores] = line.split()[1:3]
        task_type = n_types;
        if (line.find("terminate")>=0):
            task_type = 12; # hack
        if (line.find("all_tasks")>=0):
            task_type = 13; # hack
        for i in range(int(n_cores)):
            cores.append( [core_type, task_type, 1, False])
        n_types += 1
        n_app_threads += int(n_cores);
    if (line.find("RISCV_APP") >=0):
        rv_app = line.split()[1]


print arg_width
print cores

n_app_cores = len(cores) 
print(n_app_cores, n_app_threads)
#print(rv_app)

out_config = open('app_config.vh','w')
out_config.write("// This file is auto-generated by gen_cores.py. Do not change\n\n");

if (app == "riscv"):
    out_config.write('parameter RISCV = 1;\n')
    out_config.write('parameter APP_NAME = \"' + rv_app + '\";\n\n')
else:
    out_config.write('parameter RISCV = 0;\n')
    out_config.write('parameter APP_NAME = \"' + app + '\";\n\n')
out_config.write('parameter ARG_WIDTH = ' + str(arg_width) + ';\n')
out_config.write('parameter APP_ID = ' + str(app_id) + ';\n')
out_config.write('parameter N_CORES = ' + str(n_app_cores) + ';\n')
#out_config.write('parameter N_APP_THREADS = ' + str(n_app_threads) + ';\n')

out_config.close()

core_spec = open('gen_core_spec.vh','w')

core_spec.write("// This file is auto-generated by gen_cores.py. Do not change\n");
core_spec.write('generate\n')

core_inst = """ 
        .ap_clk          (clk),
        .ap_rst_n        (ap_rst_n),
        .ap_start        (ap_start),
        .ap_done         (ap_done),
        .ap_idle         (ap_idle),
        .ap_ready        (ap_ready),
        .task_in         ({task_in.args, task_in.ttype, task_in.object, task_in.ts}),
        .task_out_V_TDATA   (task_out_data),
        .task_out_V_TVALID  (task_out_valid),
        .task_out_V_TREADY  (task_out_ready),
        .m_axi_l1_V_AWVALID (l1.awvalid),
        .m_axi_l1_V_AWREADY (l1.awready),
        .m_axi_l1_V_AWADDR  (l1.awaddr[31:0]),
        .m_axi_l1_V_AWLEN   (l1.awlen),
        .m_axi_l1_V_AWSIZE  (l1.awsize),
        .m_axi_l1_V_WVALID  (l1.wvalid),
        .m_axi_l1_V_WREADY  (l1.wready),
        .m_axi_l1_V_WDATA   (l1.wdata[$data_width:0]),
        .m_axi_l1_V_WSTRB   (l1.wstrb[3:0]),
        .m_axi_l1_V_WLAST   (l1.wlast),
        .m_axi_l1_V_ARVALID (l1.arvalid),
        .m_axi_l1_V_ARREADY (l1.arready),
        .m_axi_l1_V_ARADDR  (l1.araddr[31:0]),
        .m_axi_l1_V_ARLEN   (l1.arlen),
        .m_axi_l1_V_ARSIZE  (l1.arsize),
        .m_axi_l1_V_RVALID  (ap_l1_rvalid),
        .m_axi_l1_V_RREADY  (ap_l1_rready),
        .m_axi_l1_V_RDATA   (l1.rdata[$data_width:0]),
        .m_axi_l1_V_RLAST   (ap_l1_rlast),
        .m_axi_l1_V_RID     (1'b0),
        .m_axi_l1_V_RRESP   (l1.rresp),
        .m_axi_l1_V_BVALID  (ap_l1_bvalid),
        .m_axi_l1_V_BREADY  (ap_l1_bready),
        .m_axi_l1_V_BRESP   (l1.bresp),
        .m_axi_l1_V_BID     (1'b0),
        .undo_log_entry     (app_undo_log_data),
        .undo_log_entry_ap_vld (app_undo_log_valid),
        .undo_log_entry_ap_rdy (app_undo_log_ready),
        .ap_state (ap_state)
        """

if (is_hls):  # BIG HACK
    core_inst = core_inst.replace(".ap_state (ap_state)", "")
    core_inst = core_inst.replace("undo_log_entry_ap_vld", "undo_log_entry_V_TVALID")
    core_inst = core_inst.replace("undo_log_entry_ap_rdy", "undo_log_entry_V_TREADY")
    core_inst = core_inst.replace("undo_log_entry  ", "undo_log_entry_V_TDATA  ")
    core_inst = core_inst.replace("app_undo_log_ready),", "app_undo_log_ready)")

for i in range(len(cores)):
    (core_type, task_type, threads, custom) = cores[i]
    if (custom):
        continue
    core_spec.write('\tif (CORE_ID == ' + str(i) + ') begin : core_'+str(i) +'\n')
    core_spec.write('\t\tassign task_araddr = ' + str(task_type) +  ';\n')
    core_spec.write('\t\t' + core_type + ' APP_CORE (\n')

    core_spec.write(core_inst.replace('$data_width', str(data_width-1)))

    core_spec.write('\t);\n')
    core_spec.write('\tend\n')
core_spec.write('endgenerate\n')



tile_spec = open('gen_core_spec_tile.vh','w')

tile_spec.write("// This file is auto-generated by gen_cores.py. Do not change\n");
    
core_tile_inst = """
           .CORE_ID($cid),
           .TILE_ID(TILE_ID)
         ) CORE_$cid (
           .clk(clk_main_a0),
           .rstn(rst_main_n_sync),

           .reg_bus(reg_bus[ID_CORE_BEGIN+$cid]),
           .pci_debug(pci_debug[ID_CORE_BEGIN+$cid]),
            
           .task_arvalid( cc_cores_arvalid[$tid_end:$tid_start] ),
           .task_araddr ( cc_cores_araddr [$tid_end:$tid_start] ),
           .task_rvalid ( cc_cores_rvalid [$tid_end:$tid_start] ),
           .task_rdata  ( issue_task              ),
           .task_rslot  ( issue_task_cq_slot        ),
           .task_rthread( issue_task_thread       ),

           .start_task_valid( ),
           .start_task_slot ( ),
           .start_task_ready( 1'b1 ),
           
           .finish_task_valid( core_finish_task_valid[$tid_end:$tid_start]),
           .finish_task_slot ( core_finish_task_slot [$tid_end:$tid_start]),
           .finish_task_thread( core_finish_task_thread [$tid_end:$tid_start]),
           .finish_task_num_children ( core_finish_task_num_children [$tid_end:$tid_start]),
           .finish_task_undo_log_write ( core_finish_task_undo_log_write [$tid_end:$tid_start]),
           .finish_task_ready( core_finish_task_ready[$tid_end:$tid_start]),

           .task_aborted(  task_aborted ),
           .gvt_task_slot_valid  (gvt_task_slot_valid ),
           .gvt_task_slot        (gvt_task_slot       ),
            
           .task_wvalid    (cores_cm_wvalid     [3+$cid]),
           .task_wdata     (cores_cm_wdata      [3+$cid]),
           .task_wready    (cores_cm_wready     [3+$cid]),
           .task_enq_untied(cores_cm_enq_untied [3+$cid]),  
           .task_cq_slot   (cores_cm_cq_slot    [3+$cid]),
           .task_child_id  (cores_cm_child_id   [3+$cid]),

           .undo_log_valid (undo_log_valid[$tid_end:$tid_start]),
           .undo_log_ready (undo_log_ready[$tid_end:$tid_start]),
           .undo_log_id    (undo_log_id   [$tid_end:$tid_start]),
           .undo_log_addr  (undo_log_addr [$tid_end:$tid_start]),
           .undo_log_data  (undo_log_data [$tid_end:$tid_start]),
           .undo_log_slot  (undo_log_slot [$tid_end:$tid_start]),

           .l1(core_l1[$cid])
         );
         """
core_tile_l1_inst = """
         axi_decoder #(
            .ID_BASE( ($cid) << 10),
            .MAX_AWSIZE(2),
            .MAX_ARSIZE(5)
         ) CORE_L1_$cid (
           .clk(clk_main_a0),
           .rstn(rst_main_n_sync),

            .core(core_l1[$cid]),
            .l2(l1_arb[$cid])
         );

         """
cid = 0
tid = 1
for i in range(len(cores)):
    (core_type, task_type, threads, custom) = cores[i]
    mt_core_type = 'core'
    threads = int(threads)
    tid_end = tid + threads-1
    if (custom):
        mt_core_type = core_type
    tile_spec.write('\t\t\t' + mt_core_type + ' #(')
    
    inst = core_tile_inst.replace('$cid', str(cid))
    inst = inst.replace('$tid_start', str(cid))
    inst = inst.replace('$tid_end', str(cid))
    # mt cores should not be limited by one l1 read at a time limitation. 
    if (custom): 
        inst = inst.replace("core_l1", "l1_arb")

    tile_spec.write(inst)
    tile_spec.write("\n");
    if (not custom):
        tile_spec.write(core_tile_l1_inst.replace('$cid', str(cid)))
        tile_spec.write("\n");
    cid += 1
    tid = tid_end + 1



