import sys
if len(sys.argv) < 2:
    print("Usage gen_config.py app")
    exit(0)
app = sys.argv[1]

# Should be run from cl_swarm/design
configs = open("apps/"+app+"/config.vh")
arg_width = 0

cores = []

n_types = 0
n_app_threads = 0;

for line in configs:
    if (line.find('#') >=0):
        continue
    if (line.find("ARG_WIDTH") >=0):
        arg_width = int(line.split()[1])
    if (line.find("mt_core")>=0):
        [core_type, n_threads] = line.split()[1:3]
        if (n_threads <= 1) :
            printf("mt_core should have >1 thread")
            exit(0);
        cores.append( [core_type, n_types, n_threads, True])
        n_types += 1
        n_app_threads += int(n_threads);
    elif (line.find("core")>=0):
        [core_type, n_cores] = line.split()[1:3]
        task_type = n_types;
        if (line.find("terminate")>=0):
            task_type = 12; # hack
        if (line.find("all_tasks")>=0):
            task_type = 13; # hack
        for i in range(int(n_cores)):
            cores.append( [core_type, task_type, 1, False])
        n_types += 1
        n_app_threads += int(n_cores);
    if (line.find("RISCV_APP") >=0):
        rv_app = line.split()[1]


print arg_width
print cores

n_app_cores = len(cores) 
print(n_app_cores, n_app_threads)
#print(rv_app)

out_config = open('config_app.vh','w')
out_config.write("// This file is auto-generated by gen_cores.py. Do not change\n\n");

if (app == "riscv"):
    out_config.write('parameter RISCV = 1;\n')
    out_config.write('parameter APP_NAME = \"' + rv_app + '\";\n\n')
else:
    out_config.write('parameter RISCV = 0;\n')
    out_config.write('parameter APP_NAME = \"' + app + '\";\n\n')
out_config.write('parameter ARG_WIDTH = ' + str(arg_width) + ';\n')
out_config.write('parameter N_APP_CORES = ' + str(n_app_cores) + ';\n')
out_config.write('parameter N_APP_THREADS = ' + str(n_app_threads) + ';\n')

out_config.close()

core_spec = open('gen_core_spec.vh','w')

core_spec.write("// This file is auto-generated by gen_cores.py. Do not change\n");
core_spec.write('generate\n')

core_inst = """ 
        .ap_clk          (clk),
        .ap_rst_n        (ap_rst_n),
        .ap_start        (ap_start),
        .ap_done         (ap_done),
        .ap_idle         (ap_idle),
        .ap_ready        (ap_ready),
        .task_in         ({task_in.args, task_in.ttype, task_in.hint, task_in.ts}),
        .task_out_V_TDATA   (task_out_data),
        .task_out_V_TVALID  (task_out_valid),
        .task_out_V_TREADY  (task_out_ready),
        .m_axi_l1_V_AWVALID (l1.awvalid),
        .m_axi_l1_V_AWREADY (l1.awready),
        .m_axi_l1_V_AWADDR  (l1.awaddr[31:0]),
        .m_axi_l1_V_AWLEN   (l1.awlen),
        .m_axi_l1_V_AWSIZE  (l1.awsize),
        .m_axi_l1_V_WVALID  (l1.wvalid),
        .m_axi_l1_V_WREADY  (l1.wready),
        .m_axi_l1_V_WDATA   (l1.wdata[31:0]),
        .m_axi_l1_V_WSTRB   (l1.wstrb[3:0]),
        .m_axi_l1_V_WLAST   (l1.wlast),
        .m_axi_l1_V_ARVALID (l1.arvalid),
        .m_axi_l1_V_ARREADY (l1.arready),
        .m_axi_l1_V_ARADDR  (l1.araddr[31:0]),
        .m_axi_l1_V_ARLEN   (l1.arlen),
        .m_axi_l1_V_ARSIZE  (l1.arsize),
        .m_axi_l1_V_RVALID  (ap_l1_rvalid),
        .m_axi_l1_V_RREADY  (ap_l1_rready),
        .m_axi_l1_V_RDATA   (l1.rdata[31:0]),
        .m_axi_l1_V_RLAST   (ap_l1_rlast),
        .m_axi_l1_V_RID     (1'b0),
        .m_axi_l1_V_RRESP   (l1.rresp),
        .m_axi_l1_V_BVALID  (ap_l1_bvalid),
        .m_axi_l1_V_BREADY  (ap_l1_bready),
        .m_axi_l1_V_BRESP   (l1.bresp),
        .m_axi_l1_V_BID     (1'b0),
        .undo_log_entry     (app_undo_log_data),
        .undo_log_entry_ap_vld (app_undo_log_valid),
        .undo_log_entry_ap_rdy (app_undo_log_ready),
        .ap_state (ap_state)
        """

for i in range(len(cores)):
    (core_type, task_type, threads, custom) = cores[i]
    if (custom):
        continue
    core_spec.write('\tif (CORE_ID == ' + str(i+1) + ') begin : core_'+str(i+1) +'\n')
    core_spec.write('\t\tassign task_araddr = ' + str(task_type) +  ';\n')
    core_spec.write('\t\t' + core_type + ' APP_CORE (\n')

    core_spec.write(core_inst)

    core_spec.write('\t);\n')
    core_spec.write('\tend\n')
core_spec.write('endgenerate\n')



tile_spec = open('gen_core_spec_tile.vh','w')

tile_spec.write("// This file is auto-generated by gen_cores.py. Do not change\n");
tile_spec.write('generate\n')
    
core_tile_inst = """
           .CORE_ID($cid),
           .TILE_ID(TILE_ID)
         ) CORE_$cid (
           .clk(clk_main_a0),
           .rstn(rst_main_n_sync),

           .reg_bus(reg_bus[$cid]),
           .pci_debug(pci_debug[$cid]),
            
           .task_arvalid( cc_cores_arvalid[$tid_end:$tid_start] ),
           .task_araddr ( cc_cores_araddr [$tid_end:$tid_start] ),
           .task_rvalid ( cc_cores_rvalid [$tid_end:$tid_start] ),
           .task_rdata  ( cc_cores_rdata        ),
           .task_rslot  ( cc_cores_rslot        ),

           .start_task_valid( start_task_valid[$tid_end:$tid_start]),
           .start_task_slot ( start_task_slot [$tid_end:$tid_start]),
           .start_task_ready( start_task_ready[$tid_end:$tid_start]),
           
           .finish_task_valid( finish_task_valid[$tid_end:$tid_start]),
           .finish_task_slot ( finish_task_slot [$tid_end:$tid_start]),
           .finish_task_num_children ( finish_task_num_children [$tid_end:$tid_start]),
           .finish_task_undo_log_write ( finish_task_undo_log_write [$tid_end:$tid_start]),
           .finish_task_ready( finish_task_ready[$tid_end:$tid_start]),

           .abort_running_task (abort_running_task[$tid_end:$tid_start]),
           .abort_running_slot (abort_running_slot     ),
           .gvt_task_slot_valid  (gvt_task_slot_valid ),
           .gvt_task_slot        (gvt_task_slot       ),
            
           .task_wvalid    (cores_cm_wvalid     [$cid]),
           .task_wdata     (cores_cm_wdata      [$cid]),
           .task_wready    (cores_cm_wready     [$cid]),
           .task_enq_untied(cores_cm_enq_untied [$cid]),  
           .task_cq_slot   (cores_cm_cq_slot    [$cid]),
           .task_child_id  (cores_cm_child_id   [$cid]),

           .undo_log_valid (undo_log_valid[$tid_end:$tid_start]),
           .undo_log_ready (undo_log_ready[$tid_end:$tid_start]),
           .undo_log_id    (undo_log_id   [$tid_end:$tid_start]),
           .undo_log_addr  (undo_log_addr [$tid_end:$tid_start]),
           .undo_log_data  (undo_log_data [$tid_end:$tid_start]),
           .undo_log_slot  (undo_log_slot [$tid_end:$tid_start]),

           .l1(core_l1[$cid])
         );
         """
core_tile_l1_inst = """
         axi_decoder #(
            .ID_BASE( (TILE_ID<<11) + (($cid) << 4)),
            .MAX_AWSIZE(2),
            .MAX_ARSIZE(5)
         ) CORE_L1_$cid (
           .clk(clk_main_a0),
           .rstn(rst_main_n_sync),

            .core(core_l1[$cid]),
            .l2(l1_arb[$cid])
         );

         """
cid = 0
tid = 1
for i in range(len(cores)):
    (core_type, task_type, threads, custom) = cores[i]
    mt_core_type = 'core'
    cid += 1
    threads = int(threads)
    tid_end = tid + threads-1
    if (custom):
        mt_core_type = core_type
    tile_spec.write('\t\t\t' + mt_core_type + ' #(')
    
    inst = core_tile_inst.replace('$cid', str(cid))
    inst = inst.replace('$tid_start', str(tid))
    inst = inst.replace('$tid_end', str(tid_end))
    # mt cores should not be limited by one l1 read at a time limitation. 
    if (custom): 
        inst = inst.replace("core_l1", "l1_arb")

    tile_spec.write(inst)
    tile_spec.write("\n");
    if (not custom):
        tile_spec.write(core_tile_l1_inst.replace('$cid', str(cid)))
        tile_spec.write("\n");
    tid = tid_end + 1

tile_spec.write('endgenerate\n')


